<?php

/**
 * PluginsfSympalAsset
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 6820 2009-11-30 17:27:49Z jwage $
 */

/**
 * Doctrine_Record class representing an asset object
 *
 * @package     sfSympalAssetsPlugin
 * @subpackage  Doctrine_Record
 * @author      Jonathan H. Wage <jonwage@gmail.com>
 * @since       2010-03-06
 * @version     svn:$Id$ $Author$
 */
abstract class PluginsfSympalAsset extends BasesfSympalAsset
{
  private $_assetObject;

  public function filterContent($content, $replace, $options = array())
  {
    return str_replace($replace, $this->render($options), $content);
  }

  public function setNewPath($path)
  {
    $assetObject = $this->getAssetObject();
    $assetObject->setNewPath($path);
    $this->path = $assetObject->getRelativePathDirectory();
    $this->name = $assetObject->getName();
  }

  public function move($newPath)
  {
    $this->getAssetObject()->move($newPath);
    $this->setNewPath($newPath);
  }

  public function moveTo($path)
  {
    return $this->move($path.'/'.$this->getName());
  }

  public function rename($newName)
  {
    return $this->move($this->getPathDirectory().'/'.$newName);
  }

  public function render($options = array())
  {
    return $this->getAssetObject()->render($options);
  }

  public function getEmbedCode()
  {
    return sprintf('[asset:%s]', $this->getSlug());
  }
  
  /**
   * Returns an array of default "options" to be added when an asset
   * is embedded (to eventually create strings like [asset:slug var=value]
   * 
   * @todo Hook this system up with the slot object system, and use the
   * defaults from the slot object in question as the default params
   */
  public function getEmbedOptions($jsonEncode = false)
  {
    $options = array('alt' => $this->name);
    
    return $jsonEncode ? json_encode($options) : $options;
  }

  /**
   * Returns an sfSympalAssetObject instance that represents this asset
   *
   * The actual subclass of sfSympalAssetObject will depend on the type
   * of this file, as determined by its extension
   *
   * @return sfSympalAssetObject
   */
  public function getAssetObject()
  {
    if (!$this->_assetObject)
    {
      $this->_assetObject = sfSympalAssetToolkit::createAssetObject($this->path.'/'.$this->name);
    }

    return $this->_assetObject;
  }

  /**
   * Assigns an sfSympalAssetObject to this record.
   *
   * Used primarily internally for a one-to-one relationship between
   * sfSympalAsset and sfSympalAssetObject
   */
  public function setAssetObject($assetObject)
  {
    $this->_assetObject = $assetObject;
    $this->path = $this->_assetObject->getRelativePathDirectory();
    $this->name = $this->_assetObject->getName();
  }

  public function delete(Doctrine_Connection $conn = null)
  {
    $this->getAssetObject()->delete();
    return parent::delete($conn);
  }

  public function preUpdate($event)
  {
    $this->getAssetObject()->save();
  }

  public function preInsert($event)
  {
    $this->getAssetObject()->save();
  }

  public function postInsert($event)
  {
    $this->copyOriginal();
  }

  /**
   * Copies the raw image to an "originals" directory
   */
  public function copyOriginal()
  {
    $dir = $this->getPathDirectory().'/'.sfSympalConfig::get('assets', 'originals_dir');
    if (!is_dir($dir))
    {
      mkdir($dir, 0777, true);
    }
    copy($this->getPath(), $dir.'/'.$this->getName());
  }

  public function fileExists()
  {
    return $this->getAssetObject()->exists();
  }

  /**
   * Builds a string slug based on the filename
   *
   * @return string
   */
  public static function slugBuilder($text)
  {
    if (strpos($text, '.') !== false)
    {
      $e = explode('.', $text);
      unset($e[count($e) - 1]);
      $slug = implode('.', $e);
    } else {
      $slug = $text;
    }

    return Doctrine_Inflector::urlize($slug);
  }

  public function __call($method, $arguments)
  {
    if (method_exists($this->getAssetObject(), $method))
    {
      return call_user_func_array(array($this->getAssetObject(), $method), $arguments);
    } else {
      return parent::__call($method, $arguments);
    }
  }
}